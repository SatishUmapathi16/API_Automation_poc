{
	"info": {
		"_postman_id": "aaafa715-5e5f-4e46-acd3-4948b1599226",
		"name": "Flight_Number_Search",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "19781785"
	},
	"item": [
		{
			"name": "Flight search with flight num",
			"item": [
				{
					"name": "Flight search with flight num",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// Set method dynamically\r",
									"\r",
									"// Read CSV cell which can be: 201 | 401 | Skip\r",
									"const raw = pm.iterationData.get(\"FlightNumberstatusCode\");\r",
									"const val = String(raw ?? \"\").trim();\r",
									"const isSkip = /^skip$/i.test(val);\r",
									"pm.variables.set(\"_skip_this\", isSkip ? \"true\" : \"false\");\r",
									"\r",
									"if (isSkip) {\r",
									"    pm.request.method = \"GET\";          // harmless method\r",
									"    pm.request.body = null;             // clear request body\r",
									"    // Point to a safe, fast endpoint (returns 204 No Content)\r",
									"    pm.request.url.update(\"https://postman-echo.com/status/204\");\r",
									"\r",
									"    console.log(\"[SKIP] SoftRefresh request skipped. Redirected to 204 echo endpoint.\");\r",
									"    return; // stop further pre-request logic\r",
									"}\r",
									"let method = pm.iterationData.get(\"FlightNumberhttpMethod\");\r",
									"if (method) {\r",
									"    pm.request.method = method; // override method type\r",
									"}\r",
									"console.log(\"HTTP Method:\", method);\r",
									"const statusCodeRaw = pm.iterationData.get(\"FlightNumberstatusCode\");\r",
									"const statusCode = typeof statusCodeRaw === \"number\"\r",
									"    ? statusCodeRaw\r",
									"    : parseInt(String(statusCodeRaw || \"\").trim(), 10);\r",
									"\r",
									"if(statusCode===200){\r",
									"pm.variables.set(\"flightNumber\", \"61\");\r",
									"pm.variables.set(\"departureDate\", \"2025-09-09\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									"\r",
									"\r",
									"\r",
									"    if (statusCode === 400) {\r",
									"    const missingFieldRaw = pm.iterationData.get(\"FlightNUmberMissingField\");\r",
									"    const missingField = String(missingFieldRaw || \"\").trim();\r",
									"\r",
									"    if(missingField==\"FlightNumber\"){\r",
									"   pm.variables.set(\"flightNumber\", \"\");\r",
									"pm.variables.set(\"departureDate\", \"2025-09-09\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									"\r",
									"  \r",
									" \r",
									"\r",
									"  if(missingField==\"date\"){\r",
									"   pm.variables.set(\"flightNumber\", \"61\");\r",
									"pm.variables.set(\"departureDate\", \"\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									" if(missingField==\"invalidDate\"){\r",
									"   pm.variables.set(\"flightNumber\", \"61\");\r",
									"pm.variables.set(\"departureDate\", \"09-09-2025\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									"\r",
									" if(missingField==\"blankBody\"){\r",
									"   pm.variables.set(\"flightNumber\", \"\");\r",
									"pm.variables.set(\"departureDate\", \"\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									"\r",
									"if(missingField==\"InvalidFlightNumber\"){\r",
									"   pm.variables.set(\"flightNumber\", \"555555534559\");\r",
									"pm.variables.set(\"departureDate\", \"2025-09-09\");\r",
									"pm.variables.set(\"langCode\", pm.iterationData.get(\"FlightNumberlangCode\"));\r",
									"\r",
									"}\r",
									" \r",
									"\r",
									"  }\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// === Step 1: Read status or 'Skip' from CSV ===\r",
									"const raw = pm.iterationData.get(\"FlightNumberstatusCode\");\r",
									"const val = String(raw ?? \"\").trim();\r",
									"const isSkip = /^skip$/i.test(val);\r",
									"pm.variables.set(\"_skip_this\", isSkip ? \"true\" : \"false\");\r",
									"\r",
									"// ---- Soft helper (define once, safely) ----\r",
									"if (typeof softTestWithFailSuffix !== 'function') {\r",
									"  var softTestWithFailSuffix = function (title, validateFn) {\r",
									"    var failed = false, msg = \"\";\r",
									"    try { validateFn(); } catch (e) { failed = true; msg = (e && e.message) ? e.message : String(e); }\r",
									"    var finalTitle = failed ? (title + \" + --> Failing\") : title;\r",
									"    pm.test(finalTitle, function () {\r",
									"      if (failed) console.warn(\"[SOFT] \" + title + \" → \" + msg);\r",
									"      pm.expect(true).to.be.true; // always pass\r",
									"    });\r",
									"  };\r",
									"}\r",
									"\r",
									"// === Step 2: If Skip, prevent real API hit (via blackhole)\r",
									"if (isSkip) {\r",
									"  pm.test(\"[SKIP] Request skipped via CSV\", function () {\r",
									"    pm.expect(true).to.be.true;\r",
									"  });\r",
									"  return;\r",
									"}\r",
									"\r",
									"// === Fetch expected status and response time ===\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"FlightNumberstatusCode\"), 10);\r",
									"const expectedTime = 1000;\r",
									"\r",
									"// === 1. Validate Status Code (SOFT when expecting 405) ===\r",
									"if (expectedStatus === 405) {\r",
									"  softTestWithFailSuffix(`Validate Status code should be ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"} else {\r",
									"  pm.test(`Validate Status code should be ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"}\r",
									"\r",
									"// === 2. Validate Content-Type ===\r",
									"pm.test(\" Validate Content-Type header\", function () {\r",
									"  const contentType = pm.response.headers.get(\"Content-Type\") || \"\";\r",
									"  pm.expect(contentType).to.match(/application\\/json|text\\/html/i);\r",
									"});\r",
									"\r",
									"\r",
									"// ======================= 200 OK =======================\r",
									"if (expectedStatus === 200) {\r",
									"  let responseData = pm.response.json();\r",
									"  const flightStatus = responseData.flightStatus;\r",
									"\r",
									"  // === 3. Response time under limit (informational) ===\r",
									"  pm.test(`Response time is ${pm.response.responseTime} ms`, function () {\r",
									"    pm.expect(true).to.equal(true);\r",
									"  });\r",
									"\r",
									"  pm.test(\"Validate the flightStatus object structure\", function () {\r",
									"    pm.expect(responseData).to.be.an('object');\r",
									"    pm.expect(responseData.flightStatus).to.be.an('object');\r",
									"\r",
									"    pm.expect(flightStatus).to.have.all.keys(\r",
									"      'searchOrigin', 'searchDestination', 'searchDate', 'onds', 'searchOriginCity', 'searchDestinationCity'\r",
									"    );\r",
									"\r",
									"    pm.expect(flightStatus.onds).to.be.an('array');\r",
									"\r",
									"    flightStatus.onds.forEach(function (ond) {\r",
									"      pm.expect(ond).to.be.an('object');\r",
									"      pm.expect(ond).to.have.all.keys('origin', 'destination', 'flights', 'originCity', 'destinationCity');\r",
									"      pm.expect(ond.flights).to.be.an('array');\r",
									"\r",
									"      ond.flights.forEach(function (flight) {\r",
									"        pm.expect(flight).to.be.an('object');\r",
									"        pm.expect(flight).to.have.all.keys(\r",
									"          'carrier', 'flightNumber', 'flightStatus', 'flightStatusCode', 'equipment',\r",
									"          'departure', 'arrival', 'engFlightStatus', 'statusType', 'duration', 'isExpanded'\r",
									"        );\r",
									"\r",
									"        pm.expect(flight.departure).to.be.an('object');\r",
									"        pm.expect(flight.departure).to.have.all.keys(\r",
									"          'locationCode', 'scheduledDate', 'scheduledTime', 'terminal', 'timeDifference', 'timeZone',\r",
									"          'airportName', 'cityName', 'scheduledDisplayFlag', 'strikeoutFlag', 'updatedTimestampFlag',\r",
									"          'updatedTimestampColor', 'updatedDatestamp', 'updatedTimestamp', 'strikeoutDateFlag'\r",
									"        );\r",
									"\r",
									"        pm.expect(flight.arrival).to.be.an('object');\r",
									"        pm.expect(flight.arrival).to.have.all.keys(\r",
									"          'locationCode', 'scheduledDate', 'scheduledTime', 'terminal', 'timeDifference', 'timeZone',\r",
									"          'airportName', 'cityName', 'scheduledDisplayFlag', 'strikeoutFlag', 'updatedTimestampFlag',\r",
									"          'updatedTimestampColor', 'updatedDatestamp', 'updatedTimestamp', 'strikeoutDateFlag'\r",
									"        );\r",
									"      });\r",
									"    });\r",
									"  });\r",
									"\r",
									"  const onds = (responseData.flightStatus && responseData.flightStatus.onds) || [];\r",
									"\r",
									"  // ONDs and Flights validation\r",
									"  onds.forEach((ond) => {\r",
									"    pm.test(`Validate  flight object key`, function () {\r",
									"      pm.expect(ond).to.be.an('object');\r",
									"      pm.expect(ond).to.include.all.keys('origin', 'destination', 'flights', 'originCity', 'destinationCity');\r",
									"    });\r",
									"\r",
									"    pm.test(`Validate flights is an array`, function () {\r",
									"      pm.expect(ond).to.have.property('flights').that.is.an('array');\r",
									"    });\r",
									"\r",
									"    const flights = ond.flights || [];\r",
									"    flights.forEach((flight) => {\r",
									"      pm.test(`Validate flights core fields present`, function () {\r",
									"        pm.expect(flight).to.be.an('object');\r",
									"        pm.expect(flight).to.include.all.keys(\r",
									"          'carrier', 'flightNumber', 'flightStatus', 'flightStatusCode', 'equipment',\r",
									"          'departure', 'arrival', 'engFlightStatus', 'statusType', 'duration', 'isExpanded'\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights core field types`, function () {\r",
									"        pm.expect(flight.carrier).to.be.a('string').and.not.empty;\r",
									"        pm.expect(String(flight.flightNumber)).to.match(/^\\d{1,4}$/);\r",
									"        pm.expect(flight.flightStatus).to.be.a('string');\r",
									"        pm.expect(flight.flightStatusCode).to.be.a('string');\r",
									"        pm.expect(flight.equipment).to.be.a('string');\r",
									"        pm.expect(flight.engFlightStatus).to.be.a('string');\r",
									"        pm.expect(flight.statusType).to.be.a('string');\r",
									"        pm.expect(flight.duration).to.match(/^\\d{2}:\\d{2}$/);\r",
									"        pm.expect(flight.isExpanded).to.be.a('boolean');\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights departure object key`, function () {\r",
									"        pm.expect(flight.departure).to.be.an('object');\r",
									"        pm.expect(flight.departure).to.include.all.keys(\r",
									"          'locationCode', 'scheduledDate', 'scheduledTime', 'terminal', 'timeDifference', 'timeZone',\r",
									"          'airportName', 'cityName', 'scheduledDisplayFlag', 'strikeoutFlag', 'updatedTimestampFlag',\r",
									"          'updatedTimestampColor', 'updatedDatestamp', 'updatedTimestamp', 'strikeoutDateFlag'\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights departure key data type`, function () {\r",
									"        const d = flight.departure;\r",
									"        pm.expect(d.locationCode).to.be.a('string').and.not.empty;\r",
									"        pm.expect(d.scheduledDate).to.match(/^\\d{4}-\\d{2}-\\d{2}$/);\r",
									"        pm.expect(d.scheduledTime).to.match(/^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}$/);\r",
									"        pm.expect(d.timeZone).to.match(/^[+\\-]\\d{4}$/);\r",
									"        pm.expect(d.scheduledDisplayFlag).to.be.a('boolean');\r",
									"        pm.expect(d.strikeoutFlag).to.be.a('boolean');\r",
									"        pm.expect(d.strikeoutDateFlag).to.be.a('boolean');\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights arrival object key`, function () {\r",
									"        pm.expect(flight.arrival).to.be.an('object');\r",
									"        pm.expect(flight.arrival).to.include.all.keys(\r",
									"          'locationCode', 'scheduledDate', 'scheduledTime', 'terminal', 'timeDifference', 'timeZone',\r",
									"          'airportName', 'cityName', 'scheduledDisplayFlag', 'strikeoutFlag', 'updatedTimestampFlag',\r",
									"          'updatedTimestampColor', 'updatedDatestamp', 'updatedTimestamp', 'strikeoutDateFlag'\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights arrival object key data type`, function () {\r",
									"        const a = flight.arrival;\r",
									"        pm.expect(a.locationCode).to.be.a('string').and.not.empty;\r",
									"        pm.expect(a.scheduledDate).to.match(/^\\d{4}-\\d{2}-\\d{2}$/);\r",
									"        pm.expect(a.scheduledTime).to.match(/^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}$/);\r",
									"        pm.expect(a.timeZone).to.match(/^[+\\-]\\d{4}$/);\r",
									"        pm.expect(a.scheduledDisplayFlag).to.be.a('boolean');\r",
									"        pm.expect(a.strikeoutFlag).to.be.a('boolean');\r",
									"        pm.expect(a.strikeoutDateFlag).to.be.a('boolean');\r",
									"      });\r",
									"    });\r",
									"\r",
									"    pm.expect(responseData.flightStatus.searchOriginCity)\r",
									"      .to.exist.and.to.be.a('string').and.to.have.lengthOf.at.least(1);\r",
									"    pm.expect(responseData.flightStatus.searchDestinationCity)\r",
									"      .to.exist.and.to.be.a('string').and.to.have.lengthOf.at.least(1);\r",
									"  });\r",
									"\r",
									"  // Language-specific checks\r",
									"  if (pm.iterationData.get(\"FlightNumberlangCode\") === \"ar\") {\r",
									"    const extendedArabicRegex = /^[\\u0600-\\u06FF\\s\\uFB50-\\uFDFF\\uFE70-\\uFEFF]+$/;\r",
									"\r",
									"    pm.test(\"Validate Departure AirportName contains only Arabic characters\", function () {\r",
									"      pm.expect(responseData).to.be.an('object');\r",
									"      const n = responseData.flightStatus.onds[0].flights[0].departure.airportName;\r",
									"      pm.expect(n).to.exist;\r",
									"      pm.expect(n).to.match(extendedArabicRegex, \"AirportName should contain only Arabic characters\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate CityName in the departure section contains only Arabic characters\", function () {\r",
									"      const cityName = responseData.flightStatus.onds[0].flights[0].departure.cityName;\r",
									"      pm.expect(cityName).to.exist;\r",
									"      pm.expect(cityName).to.match(extendedArabicRegex, \"CityName should contain only Arabic characters\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate AirportName in arrival section contains only Arabic characters\", function () {\r",
									"      const arrivalAirportName = responseData.flightStatus.onds[0].flights[0].arrival.airportName;\r",
									"      if (arrivalAirportName) {\r",
									"        pm.expect(arrivalAirportName).to.match(extendedArabicRegex, \"AirportName should contain only Arabic characters\");\r",
									"      } else {\r",
									"        pm.expect.fail(\"Arrival section or AirportName does not exist\");\r",
									"      }\r",
									"    });\r",
									"\r",
									"    pm.test(\"CityName in the arrival section contains only Arabic characters\", function () {\r",
									"      const arrivalCityName = responseData.flightStatus.onds[0].flights[0].arrival.cityName;\r",
									"      pm.expect(arrivalCityName).to.exist.and.to.satisfy(function (cityName) {\r",
									"        return extendedArabicRegex.test(cityName);\r",
									"      }, \"CityName should contain only Arabic characters\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (pm.iterationData.get(\"FlightNumberlangCode\") === \"en\") {\r",
									"    pm.test(\"Validate AirportName in departure section contains only English characters\", function () {\r",
									"      pm.expect(responseData).to.be.an('object');\r",
									"      responseData.flightStatus.onds.forEach(ond => {\r",
									"        ond.flights.forEach(flight => {\r",
									"          const airportName = flight.departure.airportName;\r",
									"          pm.expect(airportName).to.match(/^[A-Za-z\\s]+$/, \"AirportName should contain only English characters\");\r",
									"        });\r",
									"      });\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate CityName in departure section contains only English characters\", function () {\r",
									"      const cityName = responseData.flightStatus.onds[0].flights[0].departure.cityName;\r",
									"      pm.expect(cityName).to.match(/^[A-Za-z\\s]+$/, \"CityName should only contain English characters\");\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate Airport Name in arrival section contains only English characters\", function () {\r",
									"      pm.expect(responseData).to.be.an('object');\r",
									"      responseData.flightStatus.onds.forEach(ond => {\r",
									"        ond.flights.forEach(flight => {\r",
									"          const airportName = flight.arrival.airportName;\r",
									"          pm.expect(airportName).to.match(/^[A-Za-z\\s]+$/, \"Airport Name should contain only English characters\");\r",
									"        });\r",
									"      });\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate CityName in arrival section contains only English characters\", function () {\r",
									"      pm.expect(responseData).to.be.an('object');\r",
									"      responseData.flightStatus.onds.forEach(ond => {\r",
									"        ond.flights.forEach(flight => {\r",
									"          const cityName = flight.arrival.cityName;\r",
									"          pm.expect(cityName).to.match(/^[A-Za-z\\s]+$/, \"CityName should contain only English characters\");\r",
									"        });\r",
									"      });\r",
									"    });\r",
									"  }\r",
									"\r",
									"  const flightNumber = responseData.flightStatus.onds[0].flights[0].flightNumber;\r",
									"  pm.test(\"Validate Flight number length should be between 1 and 4\", function () {\r",
									"    pm.expect(flightNumber, 'flightNumber should be a string').to.be.a('string');\r",
									"    pm.expect(flightNumber.length, 'flightNumber length').to.be.within(1, 4);\r",
									"  });\r",
									"\r",
									"  pm.test(\"Validate  search origin and search destination are of length 3\", () => {\r",
									"    const tripDestination = responseData.flightStatus.searchDestination;\r",
									"    const tripOrigin = responseData.flightStatus.searchOrigin;\r",
									"    pm.expect(tripOrigin.length, 'Origin length').to.eql(3);\r",
									"    pm.expect(tripDestination.length, 'Destination length').to.eql(3);\r",
									"  });\r",
									"\r",
									"  pm.test(\"Validate origin and destination are of length 3\", () => {\r",
									"    const tripDestination = responseData.flightStatus.onds[0].destination;\r",
									"    const tripOrigin = responseData.flightStatus.onds[0].origin;\r",
									"    pm.expect(tripOrigin.length, 'Origin length').to.eql(3);\r",
									"    pm.expect(tripDestination.length, 'Destination length').to.eql(3);\r",
									"  });\r",
									"\r",
									"  pm.test(\"Validate flightStatus object has required properties\", function () {\r",
									"    pm.expect(flightStatus).to.have.property('searchOrigin').that.is.a('string');\r",
									"    pm.expect(flightStatus).to.have.property('searchDestination').that.is.a('string');\r",
									"    pm.expect(flightStatus).to.have.property('searchDate').that.is.a('string');\r",
									"    pm.expect(flightStatus).to.have.property('onds').that.is.an('array');\r",
									"    pm.expect(flightStatus).to.have.property('searchOriginCity').that.is.a('string');\r",
									"    pm.expect(flightStatus).to.have.property('searchDestinationCity').that.is.a('string');\r",
									"  });\r",
									"\r",
									"  pm.test(\"Validate valid flight objects\", function () {\r",
									"    flightStatus.onds.forEach((ond) => {\r",
									"      pm.expect(ond).to.have.property('origin').that.is.a('string');\r",
									"      pm.expect(ond).to.have.property('destination').that.is.a('string');\r",
									"      pm.expect(ond).to.have.property('flights').that.is.an('array');\r",
									"      ond.flights.forEach((flight) => {\r",
									"        pm.expect(flight).to.have.property('carrier').that.is.a('string');\r",
									"        pm.expect(flight).to.have.property('flightNumber').that.is.a('string');\r",
									"        pm.expect(flight).to.have.property('departure').that.is.an('object');\r",
									"        pm.expect(flight).to.have.property('arrival').that.is.an('object');\r",
									"        pm.expect(flight).to.have.property('duration').that.is.a('string');\r",
									"        pm.expect(flight).to.have.property('flightStatus').that.is.a('string');\r",
									"      });\r",
									"    });\r",
									"  });\r",
									"}\r",
									"\r",
									"// ======================= 400 Bad Request =======================\r",
									"if (expectedStatus === 400) {\r",
									"  const missingFieldRaw = pm.iterationData.get(\"FlightNUmberMissingField\");\r",
									"  const missingField = String(missingFieldRaw || \"\").trim();\r",
									"\r",
									"  if (missingField === \"FlightNumber\") {\r",
									"    pm.test(\" Validate error message for blank flight number => '\\\"flightNumber\\\" is not allowed to be empty'\", function () {\r",
									"      const responseData = pm.response.json();\r",
									"      const errorObj = responseData.apiErrors[0];\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-101\");\r",
									"      pm.expect(errorObj.source).to.eql(\"flightNumber\");\r",
									"      pm.expect(errorObj.message).to.eql(\"\\\"flightNumber\\\" is not allowed to be empty\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  const responseData = pm.response.json();\r",
									"  const errorObj = responseData.apiErrors[0];\r",
									"\r",
									"  if (missingField === \"date\") {\r",
									"    pm.test(\"Validate error message for invalid date => '\\\"departureDate\\\" must be a valid date'\", function () {\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-101\");\r",
									"      pm.expect(errorObj.source).to.eql(\"departureDate\");\r",
									"      pm.expect(errorObj.message).to.eql(\"\\\"departureDate\\\" must be a valid date\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (missingField === \"invalidDate\") {\r",
									"    pm.test(\"Validate error message  for invalid date => 'Unable to find flight details'\", function () {\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-103\");\r",
									"      pm.expect(errorObj.source).to.eql(\"Flight Status\");\r",
									"      pm.expect(errorObj.message).to.eql(\"Unable to find flight details\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (missingField === \"blankBody\") {\r",
									"    pm.test(\"Validate error message with blank body => '\\\"flightNumber\\\" is not allowed to be empty'\", function () {\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-101\");\r",
									"      pm.expect(errorObj.source).to.eql(\"flightNumber\");\r",
									"      pm.expect(errorObj.message).to.eql(\"\\\"flightNumber\\\" is not allowed to be empty\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (missingField === \"InvalidFlightNumber\") {\r",
									"    pm.test(\"Validate error message when flight number is invalid => \\\"flightNumber\\\" must be a string\", function () {\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-103\");\r",
									"      pm.expect(errorObj.source).to.eql(\"Flight Status\");\r",
									"      pm.expect(errorObj.message).to.eql(\"\\\"flightNumber\\\" must be a string\");\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (missingField === \"FlightNumberInNumber\") {\r",
									"    pm.test(\"Validate error message flight number is invalid =>'Unable to find flight details'\", function () {\r",
									"      pm.expect(errorObj.type).to.eql(\"error\");\r",
									"      pm.expect(errorObj.code).to.eql(\"EYCOM-FS-BFF-103\");\r",
									"      pm.expect(errorObj.source).to.eql(\"Flight Status\");\r",
									"      pm.expect(errorObj.message).to.eql(\"Unable to find flight details\");\r",
									"    });\r",
									"  }\r",
									"}\r",
									"\r",
									"// ======================= 405 Method Not Allowed (SOFT) =======================\r",
									"// (Handled by the single soft/hard status assertion above)\r",
									"\r",
									"\r",
									"// ======================= 500 Internal Server Error =======================\r",
									"if (pm.response.code === 500) {\r",
									"  const body500 = (() => { try { return pm.response.json(); } catch { return {}; } })();\r",
									"  pm.test(\"Getting Internal server error 500\", function () {\r",
									"    pm.expect(body500).to.have.property(\"message\", \"Internal server error\");\r",
									"  });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "was-secret",
								"value": "3rXypRXEsRDSUe7i2hWs",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"flightNumber\": \"{{flightNumber}}\",\r\n    \"departureDate\": \"{{departureDate}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseURL}}/ada-services/bff-flight-status/service/flight-status/v1/by-flight-number?languageCode={{langCode}}",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"ada-services",
								"bff-flight-status",
								"service",
								"flight-status",
								"v1",
								"by-flight-number"
							],
							"query": [
								{
									"key": "languageCode",
									"value": "{{langCode}}"
								}
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Flight search with origin and destination",
			"item": [
				{
					"name": "Flight search with origin and destination",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									"// --- Read status or Skip flag ---\r",
									"const raw = pm.iterationData.get(\"OriginstatusCode\");\r",
									"const val = String(raw ?? \"\").trim();\r",
									"const isSkip = /^skip$/i.test(val);\r",
									"pm.environment.set(\"_skip_this\", isSkip ? \"true\" : \"false\");\r",
									"\r",
									"// --- Robust YYYY-MM-DD for Asia/Dubai (default +1 day) ---\r",
									"function ymdDubaiPlus(daysAhead = 1) {\r",
									"  // Prefer Intl with timeZone; fallback to manual UTC+4 calculation if needed\r",
									"  try {\r",
									"    const parts = new Intl.DateTimeFormat(\"en-GB\", {\r",
									"      timeZone: \"Asia/Dubai\",\r",
									"      year: \"numeric\", month: \"2-digit\", day: \"2-digit\"\r",
									"    }).formatToParts(new Date())\r",
									"      .reduce((a, p) => (a[p.type] = p.value, a), {});\r",
									"\r",
									"    // Build midnight Dubai in UTC, then add days in UTC (avoids DST issues)\r",
									"    const dt = new Date(Date.UTC(+parts.year, +parts.month - 1, +parts.day, 0, 0, 0, 0));\r",
									"    dt.setUTCDate(dt.getUTCDate() + daysAhead);\r",
									"    const y = dt.getUTCFullYear();\r",
									"    const m = String(dt.getUTCMonth() + 1).padStart(2, \"0\");\r",
									"    const d = String(dt.getUTCDate()).padStart(2, \"0\");\r",
									"    return `${y}-${m}-${d}`;\r",
									"  } catch {\r",
									"    // Fallback: Dubai is UTC+4 (no DST). Convert local → Dubai, then add days.\r",
									"    const now = new Date();\r",
									"    const minutesToDubai = 240 + now.getTimezoneOffset(); // 240=+4h\r",
									"    const dubaiNow = new Date(now.getTime() + minutesToDubai * 60000);\r",
									"    dubaiNow.setHours(0, 0, 0, 0);\r",
									"    dubaiNow.setDate(dubaiNow.getDate() + daysAhead);\r",
									"    const y = dubaiNow.getFullYear();\r",
									"    const m = String(dubaiNow.getMonth() + 1).padStart(2, \"0\");\r",
									"    const d = String(dubaiNow.getDate()).padStart(2, \"0\");\r",
									"    return `${y}-${m}-${d}`;\r",
									"  }\r",
									"}\r",
									"\r",
									"const FUTURE_BEGIN_DATE = ymdDubaiPlus(1); // tomorrow in Dubai (YYYY-MM-DD)\r",
									"\r",
									"// If you really want to skip the real call, handle it in the request itself\r",
									"// (e.g., with a disabled request or a separate \"blackhole\" request).\r",
									"if (isSkip) {\r",
									"  // Still set variables so placeholders don’t show up in Newman logs\r",
									"  pm.environment.set(\"origin\", \"\");\r",
									"  pm.environment.set(\"destination\", \"\");\r",
									"  pm.environment.set(\"beginDate\", \"\");\r",
									"  pm.environment.set(\"langCode\", pm.iterationData.get(\"originlangCode\"));\r",
									"  console.log(\"[SKIP] Marked to skip; variables set blank.\");\r",
									"  return;\r",
									"}\r",
									"\r",
									"// --- Determine scenario from CSV ---\r",
									"const statusCodeRaw = pm.iterationData.get(\"OriginstatusCode\");\r",
									"const statusCode = (typeof statusCodeRaw === \"number\")\r",
									"  ? statusCodeRaw\r",
									"  : parseInt(String(statusCodeRaw || \"\").trim(), 10);\r",
									"\r",
									"const missingFieldRaw = pm.iterationData.get(\"MissingField\");\r",
									"const missingField = String(missingFieldRaw || \"\").trim();\r",
									"const langCode = pm.iterationData.get(\"originlangCode\");\r",
									"\r",
									"// --- Populate variables (write to ENV or COLLECTION scope) ---\r",
									"if (statusCode === 200) {\r",
									"  pm.environment.set(\"origin\", \"AUH\");\r",
									"  pm.environment.set(\"destination\", \"LHR\");\r",
									"  pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"  pm.environment.set(\"langCode\", langCode);\r",
									"}\r",
									"\r",
									"if (statusCode === 400) {\r",
									"  switch (missingField) {\r",
									"    case \"InvalidOrigin\":\r",
									"      pm.environment.set(\"origin\", \"BOMBAY\");\r",
									"      pm.environment.set(\"destination\", \"LHR\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    case \"InvalidDest\":\r",
									"      pm.environment.set(\"origin\", \"AUH\");\r",
									"      pm.environment.set(\"destination\", \"BOMBAY\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    case \"sameOriginDest\":\r",
									"      pm.environment.set(\"origin\", \"AUH\");\r",
									"      pm.environment.set(\"destination\", \"AUH\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    case \"OriginBlank\":\r",
									"      pm.environment.set(\"origin\", \"\");\r",
									"      pm.environment.set(\"destination\", \"LHR\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    case \"DestiBlank\":\r",
									"      pm.environment.set(\"origin\", \"AUH\");\r",
									"      pm.environment.set(\"destination\", \"\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    case \"DateBlank\":\r",
									"      pm.environment.set(\"origin\", \"AUH\");\r",
									"      pm.environment.set(\"destination\", \"LHR\");\r",
									"      pm.environment.set(\"beginDate\", \"\"); // intentionally blank for negative case\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"      break;\r",
									"    default:\r",
									"      // Safe default\r",
									"      pm.environment.set(\"origin\", \"AUH\");\r",
									"      pm.environment.set(\"destination\", \"LHR\");\r",
									"      pm.environment.set(\"beginDate\", FUTURE_BEGIN_DATE);\r",
									"      pm.environment.set(\"langCode\", langCode);\r",
									"  }\r",
									"}\r",
									"\r",
									"// Log what we set (handy in Newman)\r",
									"console.log(\"origin =\", pm.environment.get(\"origin\"));\r",
									"console.log(\"destination =\", pm.environment.get(\"destination\"));\r",
									"console.log(\"beginDate =\", pm.environment.get(\"beginDate\"));\r",
									"console.log(\"langCode =\", pm.environment.get(\"langCode\"));\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"// === Step 1: Read status or 'Skip' ===\r",
									"const raw = pm.iterationData.get(\"OriginstatusCode\");\r",
									"const val = String(raw ?? \"\").trim();\r",
									"const isSkip = /^skip$/i.test(val);\r",
									"pm.variables.set(\"_skip_this\", isSkip ? \"true\" : \"false\");\r",
									"\r",
									"// === Soft helpers (define once) ===\r",
									"if (typeof softTestWithFailSuffix !== \"function\") {\r",
									"  var softTestWithFailSuffix = function (title, validateFn) {\r",
									"    var failed = false, msg = \"\";\r",
									"    try { validateFn(); } catch (e) { failed = true; msg = (e && e.message) ? e.message : String(e); }\r",
									"    var finalTitle = failed ? (title + \" + --> Failing\") : title;\r",
									"    pm.test(finalTitle, function () {\r",
									"      if (failed) console.warn(\"[SOFT] \" + title + \" → \" + msg);\r",
									"      pm.expect(true).to.be.true; // always pass\r",
									"    });\r",
									"  };\r",
									"}\r",
									"\r",
									"if (typeof softCheckEA !== \"function\") {\r",
									"  var softCheckEA = function (title, expectedLabel, actualValue, validateFn) {\r",
									"    var failed = false, msg = \"\";\r",
									"    try { validateFn(); } catch (e) { failed = true; msg = (e && e.message) ? e.message : String(e); }\r",
									"    var base = title + \" | Expected: \" + expectedLabel + \" | Actual: \" + String(actualValue);\r",
									"    var finalTitle = failed ? (base + \" + --> Failing\") : base;\r",
									"    pm.test(finalTitle, function () {\r",
									"      if (failed) console.warn(\"[SOFT] \" + title + \" → \" + msg);\r",
									"      pm.expect(true).to.be.true; // always pass\r",
									"    });\r",
									"  };\r",
									"}\r",
									"\r",
									"// === Step 2: Skip guard ===\r",
									"if (isSkip) {\r",
									"  pm.test(\"[SKIP] Request skipped via CSV\", function () { pm.expect(true).to.be.true; });\r",
									"  return;\r",
									"}\r",
									"\r",
									"// === Expecteds ===\r",
									"const expectedStatus = parseInt(pm.iterationData.get(\"OriginstatusCode\"), 10);\r",
									"const expectedTime = 1000;\r",
									"\r",
									"// === Status Code (SOFT only for 405) ===\r",
									"if (expectedStatus === 405) {\r",
									"  softTestWithFailSuffix(`Validate Status code should be ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"} else {\r",
									"  pm.test(`Validate Status code should be ${expectedStatus}`, function () {\r",
									"    pm.response.to.have.status(expectedStatus);\r",
									"  });\r",
									"}\r",
									"\r",
									"// === Content-Type (HARD) ===\r",
									"pm.test(\"Validate Content-Type header\", function () {\r",
									"  const contentType = pm.response.headers.get(\"Content-Type\") || \"\";\r",
									"  pm.expect(contentType).to.match(/application\\/json|text\\/html/i);\r",
									"});\r",
									"\r",
									"// ========================= 200 OK =========================\r",
									"if (expectedStatus === 200) {\r",
									"  // Response time (SOFT)\r",
									"  softCheckEA(\"Validate Response time\", `< ${expectedTime} ms`, pm.response.responseTime, function () {\r",
									"    pm.expect(pm.response.responseTime).to.be.below(expectedTime);\r",
									"  });\r",
									"\r",
									"  const responseData = pm.response.json();\r",
									"\r",
									"  // Top-level presence\r",
									"  pm.test(\"Validate Response is an object\", function () {\r",
									"    pm.expect(responseData).to.be.an(\"object\");\r",
									"  });\r",
									"  pm.test(\"Validate flightStatus object\", function () {\r",
									"    pm.expect(responseData).to.have.property(\"flightStatus\").that.is.an(\"object\");\r",
									"  });\r",
									"\r",
									"  const flightStatus = responseData.flightStatus;\r",
									"\r",
									"  // flightStatus keys\r",
									"  pm.test(\"Validate flightStatus has required keys\", function () {\r",
									"    pm.expect(flightStatus).to.include.all.keys(\r",
									"      \"searchOrigin\",\"searchDestination\",\"searchDate\",\"onds\",\"searchOriginCity\",\"searchDestinationCity\"\r",
									"    );\r",
									"  });\r",
									"\r",
									"  // onds array\r",
									"  pm.test(\"Validate flightStatus.onds is an array\", function () {\r",
									"    pm.expect(flightStatus).to.have.property(\"onds\").that.is.an(\"array\");\r",
									"  });\r",
									"\r",
									"  const onds = flightStatus.onds || [];\r",
									"\r",
									"  // OND & flights\r",
									"  onds.forEach((ond, ondIdx) => {\r",
									"    pm.test(`OND[${ondIdx}] shape`, function () {\r",
									"      pm.expect(ond).to.be.an(\"object\");\r",
									"      pm.expect(ond).to.include.all.keys(\"origin\",\"destination\",\"flights\",\"originCity\",\"destinationCity\");\r",
									"    });\r",
									"\r",
									"    const flights = ond.flights || [];\r",
									"\r",
									"    flights.forEach((flight, fIdx) => {\r",
									"      pm.test(`Validate flights[${fIdx}] core fields present`, function () {\r",
									"        pm.expect(flight).to.be.an(\"object\");\r",
									"        pm.expect(flight).to.include.all.keys(\r",
									"          \"carrier\",\"flightNumber\",\"flightStatus\",\"flightStatusCode\",\"equipment\",\r",
									"          \"departure\",\"arrival\",\"engFlightStatus\",\"statusType\",\"duration\",\"isExpanded\"\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights[${fIdx}] core field types`, function () {\r",
									"        pm.expect(flight.carrier).to.be.a(\"string\").and.not.empty;\r",
									"        pm.expect(String(flight.flightNumber)).to.match(/^\\d{1,4}$/);\r",
									"        pm.expect(flight.flightStatus).to.be.a(\"string\");\r",
									"        pm.expect(flight.flightStatusCode).to.be.a(\"string\");\r",
									"        pm.expect(flight.equipment).to.be.a(\"string\");\r",
									"        pm.expect(flight.engFlightStatus).to.be.a(\"string\");\r",
									"        pm.expect(flight.statusType).to.be.a(\"string\");\r",
									"        pm.expect(flight.duration).to.match(/^\\d{2}:\\d{2}$/);\r",
									"        pm.expect(flight.isExpanded).to.be.a(\"boolean\");\r",
									"      });\r",
									"\r",
									"      // Departure\r",
									"      pm.test(`Validate flights[${fIdx}] departure object keys`, function () {\r",
									"        pm.expect(flight.departure).to.be.an(\"object\");\r",
									"        pm.expect(flight.departure).to.include.all.keys(\r",
									"          \"locationCode\",\"scheduledDate\",\"scheduledTime\",\"terminal\",\"timeDifference\",\"timeZone\",\r",
									"          \"airportName\",\"cityName\",\"scheduledDisplayFlag\",\"strikeoutFlag\",\"updatedTimestampFlag\",\r",
									"          \"updatedTimestampColor\",\"updatedDatestamp\",\"updatedTimestamp\",\"strikeoutDateFlag\"\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights[${fIdx}] departure field types`, function () {\r",
									"        const d = flight.departure;\r",
									"        pm.expect(d.locationCode).to.be.a(\"string\").and.not.empty;\r",
									"        pm.expect(d.scheduledDate).to.match(/^\\d{4}-\\d{2}-\\d{2}$/);\r",
									"        pm.expect(d.scheduledTime).to.match(/^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}$/);\r",
									"        pm.expect(d.timeZone).to.match(/^[+\\-]\\d{4}$/);\r",
									"        pm.expect(d.scheduledDisplayFlag).to.be.a(\"boolean\");\r",
									"        pm.expect(d.strikeoutFlag).to.be.a(\"boolean\");\r",
									"        pm.expect(d.strikeoutDateFlag).to.be.a(\"boolean\");\r",
									"      });\r",
									"\r",
									"      // Arrival\r",
									"      pm.test(`Validate flights[${fIdx}] arrival object keys`, function () {\r",
									"        pm.expect(flight.arrival).to.be.an(\"object\");\r",
									"        pm.expect(flight.arrival).to.include.all.keys(\r",
									"          \"locationCode\",\"scheduledDate\",\"scheduledTime\",\"terminal\",\"timeDifference\",\"timeZone\",\r",
									"          \"airportName\",\"cityName\",\"scheduledDisplayFlag\",\"strikeoutFlag\",\"updatedTimestampFlag\",\r",
									"          \"updatedTimestampColor\",\"updatedDatestamp\",\"updatedTimestamp\",\"strikeoutDateFlag\"\r",
									"        );\r",
									"      });\r",
									"\r",
									"      pm.test(`Validate flights[${fIdx}] arrival field types`, function () {\r",
									"        const a = flight.arrival;\r",
									"        pm.expect(a.locationCode).to.be.a(\"string\").and.not.empty;\r",
									"        pm.expect(a.scheduledDate).to.match(/^\\d{4}-\\d{2}-\\d{2}$/);\r",
									"        pm.expect(a.scheduledTime).to.match(/^\\d{2}:\\d{2}:\\d{2}\\.\\d{3}$/);\r",
									"        pm.expect(a.timeZone).to.match(/^[+\\-]\\d{4}$/);\r",
									"        pm.expect(a.scheduledDisplayFlag).to.be.a(\"boolean\");\r",
									"        pm.expect(a.strikeoutFlag).to.be.a(\"boolean\");\r",
									"        pm.expect(a.strikeoutDateFlag).to.be.a(\"boolean\");\r",
									"      });\r",
									"    });\r",
									"\r",
									"    pm.test(\"Validate origin/destination city strings exist\", function () {\r",
									"      pm.expect(responseData.flightStatus.searchOriginCity).to.be.a(\"string\").and.not.empty;\r",
									"      pm.expect(responseData.flightStatus.searchDestinationCity).to.be.a(\"string\").and.not.empty;\r",
									"    });\r",
									"  });\r",
									"\r",
									"  // Simple extra checks\r",
									"  const flightNumber = responseData.flightStatus.onds?.[0]?.flights?.[0]?.flightNumber;\r",
									"  if (flightNumber) {\r",
									"    pm.test(\"Validate Flight number length should be between 1 and 4\", function () {\r",
									"      pm.expect(flightNumber, \"flightNumber should be a string\").to.be.a(\"string\");\r",
									"      pm.expect(flightNumber.length, \"flightNumber length\").to.be.within(1, 4);\r",
									"    });\r",
									"  }\r",
									"\r",
									"  pm.test(\"Validate origin and destination code lengths (search)\", function () {\r",
									"    const o = responseData.flightStatus.searchOrigin;\r",
									"    const d = responseData.flightStatus.searchDestination;\r",
									"    pm.expect(o.length, \"Origin length\").to.eql(3);\r",
									"    pm.expect(d.length, \"Destination length\").to.eql(3);\r",
									"  });\r",
									"\r",
									"  // Language-specific checks\r",
									"  if (pm.iterationData.get(\"originlangCode\") === \"en\") {\r",
									"    const engRegex = /^[A-Za-z\\s]+$/;\r",
									"    pm.test(\"Search Origin City is English\", function () {\r",
									"      pm.expect(responseData.flightStatus.searchOriginCity).to.match(engRegex);\r",
									"    });\r",
									"    pm.test(\"Search Destination City is English\", function () {\r",
									"      pm.expect(responseData.flightStatus.searchDestinationCity).to.match(engRegex);\r",
									"    });\r",
									"    pm.test(\"OND originCity is English\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].originCity).to.match(engRegex);\r",
									"    });\r",
									"    pm.test(\"OND destinationCity is English\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].destinationCity).to.match(engRegex);\r",
									"    });\r",
									"    pm.test(\"Flight Status text is English\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].flights[0].flightStatus).to.match(engRegex);\r",
									"    });\r",
									"  }\r",
									"\r",
									"  if (pm.iterationData.get(\"originlangCode\") === \"ar\") {\r",
									"    const arRegex = /^[\\u0600-\\u06FF\\s\\uFB50-\\uFDFF\\uFE70-\\uFEFF]+$/;\r",
									"    pm.test(\"Search Origin City is Arabic\", function () {\r",
									"      pm.expect(responseData.flightStatus.searchOriginCity).to.match(arRegex);\r",
									"    });\r",
									"    pm.test(\"Search Destination City is Arabic\", function () {\r",
									"      pm.expect(responseData.flightStatus.searchDestinationCity).to.match(arRegex);\r",
									"    });\r",
									"    pm.test(\"OND originCity is Arabic\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].originCity).to.match(arRegex);\r",
									"    });\r",
									"    pm.test(\"OND destinationCity is Arabic\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].destinationCity).to.match(arRegex);\r",
									"    });\r",
									"    pm.test(\"Flight Status text is Arabic\", function () {\r",
									"      pm.expect(responseData.flightStatus.onds[0].flights[1].flightStatus).to.match(arRegex);\r",
									"    });\r",
									"  }\r",
									"}\r",
									"\r",
									"// ========================= 400 Bad Request =========================\r",
									"if (expectedStatus === 400) {\r",
									"  const missingFieldRaw = pm.iterationData.get(\"MissingField\");\r",
									"  const missingField = String(missingFieldRaw || \"\").trim();\r",
									"\r",
									"  const responseData = pm.response.json();\r",
									"  const errorObj = responseData.apiErrors && responseData.apiErrors[0];\r",
									"\r",
									"  if (missingField === \"InvalidOrigin\") {\r",
									"    pm.test('Invalid origin message', function () {\r",
									"      pm.expect(errorObj.message).to.eql('\"origin\" length must be 3 characters long');\r",
									"    });\r",
									"  }\r",
									"  if (missingField === \"InvalidDest\") {\r",
									"    pm.test('Invalid destination message', function () {\r",
									"      pm.expect(errorObj.message).to.eql('\"destination\" length must be 3 characters long');\r",
									"    });\r",
									"  }\r",
									"  if (missingField === \"sameOriginDest\") {\r",
									"    pm.test('Same origin & destination message', function () {\r",
									"      pm.expect(errorObj.message).to.eql(\"Unable to find flight details\");\r",
									"    });\r",
									"  }\r",
									"  if (missingField === \"OriginBlank\") {\r",
									"    pm.test('Origin blank message', function () {\r",
									"      pm.expect(errorObj.message).to.eql('\"origin\" is not allowed to be empty');\r",
									"    });\r",
									"  }\r",
									"  if (missingField === \"DestiBlank\") {\r",
									"    pm.test('Destination blank message', function () {\r",
									"      pm.expect(errorObj.message).to.eql('\"destination\" is not allowed to be empty');\r",
									"    });\r",
									"  }\r",
									"  if (missingField === \"DateBlank\") {\r",
									"    pm.test('Date blank/invalid message', function () {\r",
									"      pm.expect(errorObj.message).to.eql('\"beginDate\" must be a valid date');\r",
									"    });\r",
									"  }\r",
									"}\r",
									"\r",
									"// ========================= 500 Internal Server Error =========================\r",
									"if (pm.response.code === 500) {\r",
									"  const body500 = (function(){ try { return pm.response.json(); } catch(e) { return {}; } })();\r",
									"  pm.test(\"Getting Internal server error\", function () {\r",
									"    pm.expect(body500).to.have.property(\"message\", \"Internal server error\");\r",
									"  });\r",
									"}\r",
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "was-secret",
								"value": "3rXypRXEsRDSUe7i2hWs",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"origin\": \"{{origin}}\",\r\n    \"destination\": \"{{destination}}\",\r\n    \"beginDate\": \"{{beginDate}}\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{baseURL}}/ada-services/bff-flight-status/service/flight-status/v1/by-ond?languageCode={{langCode}}",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"ada-services",
								"bff-flight-status",
								"service",
								"flight-status",
								"v1",
								"by-ond"
							],
							"query": [
								{
									"key": "languageCode",
									"value": "{{langCode}}"
								}
							]
						}
					},
					"response": []
				}
			]
		}
	]
}